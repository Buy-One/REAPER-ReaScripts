/**
 * JSFX Name: 16 pads MIDI Notes Map
 * Description: Map 16 pads to specific notes
 * About: Based on X-Raym_Makey Makey MIDI Notes Map.jsfx
 * Screenshot: https://i.imgur.com/6kMft2l.gifv
 * Author: X-Raym
 * Author URI: http://www.extremraym.com
 * Donation: http://www.extremraym.com/en/donation
 * Licence: GPL v3
 * REAPER: 5.0
 * Version: 1.5
 */

/**
 * Changelog:
 * v1.5 (2019-06-25)
  + Nice colored pads
  + Hide sliders, now offset with clicks
  + Infos on Pad
  + Pad brightness based on velocity
 * v1.0 (2018-30-10)
  + Initial Release
 */

desc:16 pads MIDI Notes Map

slider1:0<0,16,1{Any,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>Input Channel
slider2:36<0,127,1>Base Note

//slider4:/MIDINoteNames:none:Mapping File
//slider5:0<0,1,1{---,Reload Now}>Reload Mapping

slider10:36<0,127,1>-Pad 01
slider11:37<0,127,1>-Pad 02
slider12:38<0,127,1>-Pad 03
slider13:39<0,127,1>-Pad 04

slider14:40<0,127,1>-Pad 05
slider15:41<0,127,1>-Pad 06
slider16:42<0,127,1>-Pad 07
slider17:43<0,127,1>-Pad 08

slider18:44<0,127,1>-Pad 09
slider19:45<0,127,1>-Pad 10
slider20:46<0,127,1>-Pad 11
slider21:47<0,127,1>-Pad 12

slider22:48<0,127,1>-Pad 13
slider23:49<0,127,1>-Pad 14
slider24:50<0,127,1>-Pad 15
slider25:51<0,127,1>-Pad 16


////////////////////////////////////////////////////////////////////////////////
@init
statNoteOn = $x90;
statNoteOff = $x80;
afterTouch = $xA0;

note_buf = 1000;

////////////////////////////////////////////////////////////////////////////////
@slider
inChannel = slider1 - 1;

////////////////////////////////////////////////////////////////////////////////
@block

while
(

  midirecv(offset,msg1,note,vel) ?
  (

    // Extract message type and channel
    status = msg1 & $xF0;
    channel = msg1 & $x0F;

    // Is it on our channel?
    channel == inChannel || inChannel == -1 ?
    (
      
      // Is it a note event?
      status == statNoteOn || status == statNoteOff || status == afterTouch ?
      (
        
        status == statNoteOff || vel == 0 ? note_buf[note] = 0 : note_buf[note] = vel;
        
        // If note is in Makey Makey MIDI Range
        note >= slider2 && note <= slider2+15  ? (
          note_in = note;
          note = slider( 10 + note - slider2 ); // Get Note Out

        );
     
      );
    
    );
    
    midisend(offset, msg1, note, vel);
    
    1; // Force loop to continue until all messages have been processed
  
  );

);

@gfx 420 480

gfx_setfont(1,"Tahoma Bold",gfx_w / 4 / 3);
gfx_setfont(2,"Tahoma Bold",gfx_w / 4 / 5);

function uix_getPitName(pit) (
  pit = pit == 0 ? "C" :
        pit == 1 ? (uix.pitName&2 ? "Db" : "C#" ) :
        pit == 2 ? "D" :
        pit == 3 ? (uix.pitName&2 ? "Eb" : "D#" ) :
        pit == 4 ? "E" :
        pit == 5 ? "F" :
        pit == 6 ? (uix.pitName&2 ? "Gb" : "F#" ) :
        pit == 7 ? "G" :
        pit == 8 ? (uix.pitName&2 ? "Ab" : "G#" ) :
        pit == 9 ? "A" :
        pit == 10 ? (uix.pitName&1 ? "A#" : "Bb" ) :
        pit == 11 ? "B" ;
  strcpy(#,pit);
);

function uix_Hue2RGB(p, q, t) local(o, h) (
  t < 0 ? t += 360; t > 360 ? t -= 360;
  o = t < 60 ? p + (q - p) * t / 60:
  t < 180 ? q:
  t < 240 ? p + (q - p) * (240 - t) / 60: p;
  o;
);

function uix_HSL2RGB(h,s,l) local(q,p,h,r,g,b)(
  s = min(max(s,0),1);
  l = min(max(l,0),1);
  !s ? r=g=b=l : !l ? r=g=b=0 : l == 1 ? r=g=b=1 :(
    q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    p = 2 * l - q;
    r = uix_Hue2RGB(p, q, h + 120);
    g = uix_Hue2RGB(p, q, h);
    b = uix_Hue2RGB(p, q, h - 120);
  );
  gfx_r = r; gfx_g = g; gfx_b = b;
);

function draw_pads() local (a,i,border,pad,pad_w,j, hue)
(
  x_offset = 0;
  i = 3;
  border = 1;
  pad = 0; // zero based, up to 15
  pad_w = gfx_w / 4;
  pad_mouse = 0;
  loop( 4,
    j = 0;
    loop( 4,
      //note_in >= slider2 && note_in <= slider2+15 && pad == note_in - slider2 ? (
      note_buf[slider2 + pad] ? (
        gfx_a = 0.5+note_buf[slider2 + pad]/127/2; // From 0.5, increase based on velocity
      ) : (
        gfx_a = 0.5;
      );

      hue = (slider(pad+10)+slider2+9)%16/16*360; // value of the pad, + offset, modulo 16, percentage, multiplied by hue total val

      uix_HSL2RGB(hue,1,0.5);
      gfx_rect(j * pad_w, i * pad_w, pad_w - border, pad_w - border );
      
      x1 = j * pad_w;
      x2 = (j+1) * pad_w;
      y1 = i * pad_w;
      y2 = (i+1) * pad_w;
      mouse_x > x1 && mouse_x < x2 && mouse_y > y1 && mouse_y < y2 ? pad_mouse = pad+1; 
      
      gfx_a = 0.7;
      uix_HSL2RGB(360,10,10);
      gfx_x = j * pad_w + 10;
      gfx_y = i * pad_w + 10;
      
      gfx_setfont(2);
      gfx_drawstr(sprintf(#, "%d", pad+1));
      
      gfx_setfont(1);
      gfx_measurestr(sprintf(#, "%d", slider(pad+10)),w,h);
      gfx_x = j * pad_w + pad_w / 2 - w / 2;
      gfx_y = i * pad_w + pad_w / 2 - h / 2;
      gfx_drawstr(sprintf(#, "%d", slider(pad+10)));
      
      gfx_setfont(2);
      note_name = uix_getPitName(slider(pad+10)%12);
      gfx_y = i * pad_w + pad_w / 2 + h / 2;
      gfx_measurestr(note_name,w,h);
      gfx_x = j * pad_w + pad_w / 2 - w / 2;
      gfx_drawstr(note_name);
      
      pad_note_in = sprintf(#, "%d", slider2+pad);
      gfx_measurestr(pad_note_in, h, w);
      gfx_x = j * pad_w + pad_w - w-10;
      gfx_y = i * pad_w + 10;
      gfx_drawstr(pad_note_in);
      
      j += 1;
      pad += 1;
    );
    i -= 1;
  );
  
);

mouse_cap > last_mouse_cap && pad_mouse > 0 ? (
  mouse_cap == 1 ? offset = 1;
  mouse_cap == 2 ? offset = -1;
  slider(pad_mouse+10-1) = min(max(slider(pad_mouse+10-1) + offset,0),127);
);

last_mouse_cap = mouse_cap;

// Notes names from files

draw_pads();