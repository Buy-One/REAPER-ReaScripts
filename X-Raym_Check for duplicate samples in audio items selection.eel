// Check for duplicate samples in audio items selection
// EEL Script for Reaper
// Author: X-Raym
// Author URl: http://extremraym.com
// Source: GitHub > X-Raym > EEL Scripts for Cockos REAPER
// Source URl: https://github.com/X-Raym/REAPER-EEL-Scripts
// Licence: GPL v3
// Release Date: 01-02-2015
// Forum Thread: EEL : Check for duplicate samples in audio items selection
// Forum Thread URl: http://forum.cockos.com/

// Version: 0.8
// Version Date: 01-02-2015
// Required: Reaper 5.0 pre 8

// Inspired by the Source Time Position Tool 0.15 from Planet Nine
// http://forum.cockos.com/showthread.php?t=144822

// ----- DEBUGGING ====>
@import X-Raym_Functions - console debug messages.eel

debug = 0; // 0 => No console. 1 => Display console messages for debugging.
clean = 1; // 0 => No console cleaning before every script execution. 1 => Console cleaning before every script execution.

msg_clean();
// <==== DEBUGGING -----


// FROM PLANET NINE
function rev_sm_comp(sp1, p1, sp2, p2, cmip)
(
	ucmip =((sp2-sp1)*(cmip-p1))/(p2-p1) + sp1; // "un-compensated" marker position in *item* time
);

// FROM PLANET NINE
function src_offset(f_position, f_item, f_take) local(pos, spos)
(
	item_pos = GetMediaItemInfo_value(f_item, "D_POSITION");
	item_length = GetMediaItemInfo_value(f_item, "D_LENGTH");
	take_offset = GetMediaItemTakeInfo_value(f_take, "D_STARTOFFS");
	take_playrate = GetMediaItemTakeInfo_value(f_take, "D_PLAYRATE");
	
	cmip = (f_position - item_pos) * take_playrate; //+ take_offset; //compensated *item* position
	
	num_sm = GetTakeNumStretchMarkers(f_take); // num of SMs
	num_sm !=0 ?
	(
		sp1 = 0; p1 = 0;
		sp2=0; smc = 0;
		while (smc < num_sm) // scan stretch markers to find SM indexes either side of marker.
		(
			GetTakeStretchMarker(f_take, smc, pos, spos);
			pos <= cmip ? // compare compensated (SM-moved) with SM *pos*
			(
				smi = smc; // sm index = sm count
				sp1 = spos; // source-pos1 = source pos of this sm
				p1 = pos // pos1 = pos of this sm
			):(	
				sp2 = spos; // else source-pos2 = source pos of this sm
				p2 = pos; // pos2 = pos of this sm
				smc = num_sm+1; // exit loop
			);
			smc +=1;
		);
		GetTakeStretchMarker(lm_take, smi, p1, sp1); // get LHS SM
		smi < num_sm -1 ? 
		(
			ucmip = rev_sm_comp(sp1, p1, sp2, p2, cmip);  // calc uncompensated mkr item position (*item* time)
			section_playrate = ((sp2-sp1)/(p2-p1))*take_playrate;
		):(
			ucmip = (cmip - p1) + sp1; // beyond last SM, item time becomes sp1 at p1 and SM rate =1
			section_playrate = take_playrate;
		);
		position_source_offset = ucmip + take_offset; // convert from item pos to source position
		sm_dev_flag = num_sm>=3 && (sp1 != p1 || sp2 != p2) && (sp1-p1) != (sp2-p2) && smi < num_sm-1; // set SM deviated flag (either side SM moved)
		
	):(
	// Calculate a position's source offset, using item & take parameters...
		sp1 =0; p1 =0; sp2 =0; p2 =0; sm_dev_flag =0; // reset values if no SMs
		position_source_offset = (f_position - item_pos) * take_playrate + take_offset; // no SMs
	);
	position_source_offset; // return value
);

// FROM PLANET NINE
function show_source_item_length(item, take) 
local(len_percent)
	(
	#src_len_buf = ""; // clear #src_len_buf - (global)
	#src_itm_len_buf = ""; // clear #src_itm_len_buf - (global)
	#src_len_perc_buf = "";

	num_sm = GetTakeNumStretchMarkers(take); // num of SMs
	num_sm ==0 ? 
	(
		sp1 =0; p1 =0; sp2 =0; p2 =0; sm_dev_flag =0; // reset values if no SMs
		//section_playrate = take_playrate;
		stp = take_start_offset + (item_length * take_playrate);
	):(
		stp = src_offset(item_pos+item_length, item, take); // comp for SMs
	);
	src_item_end_time = stp; // src_item_stt_time + (item_length * take_playrate);

	//This needs to be calc'd from source time @end - source time start.
	
	
	src_item_length = src_item_end_time - src_item_stt_time; //item_length * take_playrate;
	len_percent = (src_item_length / source_length) * 100;
	//format_timestr_pos(src_item_length, #src_itm_len_buf, ecp_format); // src_item_length value is stored to #src_itm_len_buf
	//sprintf(#src_len_perc_buf,"%0.1f",len_percent); // len_percent value is stored to #src_len_perc_buf
);

// MAIN
function check_duplicate_audio() local(i, item, j, take, k)
(
	Undo_BeginBlock(); // Begining of the undo block. Leave it at the top of your main function.

	// COUNT SELECTED ITEMS
	countSelectedMediaItem = CountSelectedMediaItems(0);
	msg_tvold("Number of selected items:", countSelectedMediaItem, "%d", 1, debug);

	// LOOP THROUGH SELECTION
	j=0;
	loop(CountSelectedMediaItems(0),
		(item = GetSelectedMediaItem(0, j)) ? ( 
			
			// CHECK THE LOOP
			msg_tvoldi("J", j, "%d", 0, debug, 1);
			
			take = GetActiveTake(item);

			TakeIsMIDI(take) === 1 ? (
				
					// TAKE IS MIDI
					msg_tvold("Item ID", item, "%d", 0, debug);
					msg_s("Take is MIDI");
					msg_tvold("=====", 0, "%s", 0, debug);
				
				):(
				
					// TAKE IS AUDIO
					msg_tvold("Item ID", item, "%d", 0, debug);
					msg_s("Take is Audio");

					// GET ITEM PROPERTIES
					
					// Name
					GetTakeName(#retval, take);
					match("%s", #retval, takeName);
					msg_tvold("Take name", takeName, "%s", 0, debug);
					itemSource = GetMediaItemTake_Source(take);
					GetMediaSourceFileName(itemSource, #filenamebuf);
					itemSourceName = #filenamebuf;
					msg_stl("Item source path and name", itemSourceName, 1);

					// PLANETNINE SOURCE TIME POSITION TOOL INIT
					PCM_Source_GetSectionInfo(itemSource, offset, source_length, reverse);
					item_pos = GetMediaItemInfo_value(item, "D_POSITION");
					item_length = GetMediaItemInfo_value(item, "D_LENGTH");
					take_offset = GetMediaItemTakeInfo_value(take, "D_STARTOFFS");
					take_playrate = GetMediaItemTakeInfo_value(take, "D_PLAYRATE");
					take_start_offset = GetMediaItemTakeInfo_value(take, "D_STARTOFFS");

					
					// ITEM START SOURCE
					num_sm = GetTakeNumStretchMarkers(take); // num of SMs
					num_sm ==0 ? 
					(
						sp1 =0; p1 =0; sp2 =0; p2 =0; sm_dev_flag =0; // reset values if no SMs
						//section_playrate = take_playrate;
						stp = take_start_offset;
					):(
						stp = src_offset(item_pos, item, take); // comp for SMs
					);

					src_item_stt_time = stp; //take_start_offset;
					msg_tvold("Source in time", src_item_stt_time, "%f", 0, debug);

					
					
					// ITEM SOURCE LENGHT
					num_sm = GetTakeNumStretchMarkers(take); // num of SMs
					num_sm ==0 ? 
					(
						sp1 =0; p1 =0; sp2 =0; p2 =0; sm_dev_flag =0; // reset values if no SMs
						//section_playrate = take_playrate;
						stp = take_start_offset + (item_length * take_playrate);
					):(
						stp = src_offset(item_pos+item_length, item, take); // comp for SMs
					);
					src_item_end_time = stp; // src_item_stt_time + (item_length * take_playrate);

					//This needs to be calc'd from source time @end - source time start.	

					src_item_length = src_item_end_time - src_item_stt_time; //item_length * take_playrate;
					len_percent = (src_item_length / source_length) * 100;
					msg_tvold("Source lenght (seconds)", src_item_length, "%f", 0, debug);
					

					// ITEM END SOURCE AND LOOP NUMBER
					repeat_num = ceil(src_item_end_time/source_length)-1;
					src_item_end_time = src_item_end_time - (source_length * (ceil(src_item_end_time/source_length)-1)); // modulus = n-d*int(n/d)
					repeat_num ? ( // source repeated at cursor position?
							msg_tvold("Source loops", repeat_num, "%d", 1, debug);
						);

					// COMPARE WITH THE REST - FROM HEDA
					// this new loop searches the new pooled selected items and assigns them a "pool" attribute to filter them later.
					k=0; // starting from j, I think it works.
					loop(CountSelectedMediaItems(0),
					(compare_item = GetSelectedMediaItem(0, k)) ? (
						 	
							k != j && k > j ? (// CHECK THE LOOP
							msg_dtl("K", K, 0);
							
							// Select j item from loop

							compare_take = GetActiveTake(compare_item); // is the item selected?
							TakeIsMIDI(compare_take) === 0 ? (
								compare_itemSource = GetMediaItemTake_Source(compare_take);
								GetMediaSourceFileName(compare_itemSource, #filenamebuf2);
								compare_itemSourceName = #filenamebuf2;
								msg_stl("Compare Item source path and name", compare_itemSourceName, 1);
								#retval = "";
								GetTakeName(#retval, compare_take);
								match("%s", #retval, compare_takeName);
								msg_tvold("Compare take name", compare_takeName, "%s", 0, debug);

								PCM_Source_GetSectionInfo(compare_itemSource, compare_offset, compare_source_length, compare_reverse);
								compare_item_pos = GetMediaItemInfo_value(compare_item, "D_POSITION");
								compare_item_length = GetMediaItemInfo_value(compare_item, "D_LENGTH");
								compare_take_offset = GetMediaItemTakeInfo_value(compare_take, "D_STARTOFFS");
								compare_take_playrate = GetMediaItemTakeInfo_value(compare_take, "D_PLAYRATE");
								compare_take_start_offset = GetMediaItemTakeInfo_value(compare_take, "D_STARTOFFS");

								
								// compare_ITEM START SOURCE
								compare_num_sm = GetTakeNumStretchMarkers(compare_take); // num of SMs
								compare_num_sm ==0 ? 
								(
									compare_sp1 =0; compare_p1 =0; compare_sp2 =0; compare_p2 =0; compare_sm_dev_flag =0; // reset values if no SMs
									//section_playrate = take_playrate;
									compare_stp = compare_take_start_offset;
								):(
									compare_stp = src_offset(compare_item_pos, compare_item, compare_take); // comp for SMs
								);

								compare_src_item_stt_time = compare_stp; //take_start_offset;
								msg_tvold("Compare Source in time", compare_src_item_stt_time, "%f", 0, debug);

								
								
								// compare_ITEM SOURCE LENGHT
								compare_num_sm = GetTakeNumStretchMarkers(compare_take); // num of SMs
								compare_num_sm ==0 ? 
								(
									compare_sp1 =0; compare_p1 =0; compare_sp2 =0; compare_p2 =0; compare_sm_dev_flag =0; // reset values if no SMs
									//section_playrate = take_playrate;
									compare_stp = compare_take_start_offset + (compare_item_length * compare_take_playrate);
								):(
									compare_stp = src_offset(compare_item_pos+compare_item_length, compare_item, compare_take); // comp for SMs
								);
								compare_src_item_end_time = compare_stp; // src_item_stt_time + (item_length * take_playrate);

								//This needs to be calc'd from source time @end - source time start.	

								compare_src_item_length = compare_src_item_end_time - compare_src_item_stt_time; //item_length * take_playrate;
								compare_len_percent = (compare_src_item_length / compare_source_length) * 100;
								msg_tvold("Compare Source lenght (seconds)", compare_src_item_length, "%f", 0, debug);
								

								// compare_ITEM END SOURCE AND LOOP NUMBER
								compare_repeat_num = ceil(compare_src_item_end_time/compare_source_length)-1;
								compare_src_item_end_time = compare_src_item_end_time - (compare_source_length * (ceil(compare_src_item_end_time/compare_source_length)-1)); // modulus = n-d*int(n/d)
								compare_repeat_num ? ( // source repeated at cursor position?
										msg_tvold("Compare Source loops", compare_repeat_num, "%d", 0, debug);
									);

								// LA SAUCE
								strcmp(compare_itemSourceName,itemSourceName) === 0 ? (
									/*IF ITEM SOURCE START */

									// CONSIDER OUSER INPUTS
									msg_s("¤¤¤¤¤");
									msg_s("TWO TAKES HAVE COMMON SOURCE");
									GetTakeName(#retval, compare_take);
									match("%s", #retval, compare_takeName);
									msg_tvold("Compare take name", compare_takeName, "%s", 0, debug);
									GetTakeName(#retval, take);
									match("%s", #retval, takeName);
									msg_tvold("Take name", takeName, "%s", 0, debug);
									msg_s("¤¤¤¤¤");

									// IF ITEM SOURCE IS SUPERIOR THAN ITEM END
								):(
									msg_s("NO MATCH");
								);
							);
						);
						k+=1;
					);
				);
			j += 1;
			msg_tvold("=====", 0, "%s", 0, debug);
			);
		);
		Undo_EndBlock("Check for duplicate samples in audio items selection", 0); // End of the undo block. Leave it at the bottom of your main function.
	);
);
msg_start(); // Display characters in the console to show you the begining of the script execution.

check_duplicate_audio(); // Execute your main function

UpdateArrange(); // Update the arrangement (often needed)

msg_end(); // Display characters in the console to show you the end of the script execution.