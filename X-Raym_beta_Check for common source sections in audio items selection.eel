// Check for common source sections in audio items selection
// EEL Script for Reaper
// Author: X-Raym
// Author URl: http://extremraym.com
// Source: GitHub > X-Raym > EEL Scripts for Cockos REAPER
// Source URl: https://github.com/X-Raym/REAPER-EEL-Scripts
// Licence: GPL v3
// Release Date: 01-02-2015
// Forum Thread: EEL : Check for duplicate samples in audio items selection
// Forum Thread URl: http://forum.cockos.com/

// Version: 0.9
// Version Date: 01-02-2015
// Required: Reaper 5.0 pre 8

// Inspired by the awesome the Source Time Position Tool 0.15 from PLANET NINE
// http://forum.cockos.com/showthread.php?t=144822

// ----- DEBUGGING ====>
@import X-Raym_Functions - console debug messages.eel

debug = 0; // 0 => No console. 1 => Display console messages for debugging.
clean = 1; // 0 => No console cleaning before every script execution. 1 => Console cleaning before every script execution.

msg_clean();
// <==== DEBUGGING -----


// FROM PLANET NINE
// Return "un-compensated" marker position in *item* time
function rev_sm_comp(sp1, p1, sp2, p2, cmip)
(
	ucmip =((sp2-sp1)*(cmip-p1))/(p2-p1) + sp1;
);

// FROM PLANET NINE
function src_offset(f_position, f_item, f_take) local(pos, spos)
(
	item_pos = GetMediaItemInfo_value(f_item, "D_POSITION");
	item_length = GetMediaItemInfo_value(f_item, "D_LENGTH");
	take_offset = GetMediaItemTakeInfo_value(f_take, "D_STARTOFFS");
	take_playrate = GetMediaItemTakeInfo_value(f_take, "D_PLAYRATE");
	
	cmip = (f_position - item_pos) * take_playrate; //+ take_offset; //compensated *item* position
	
	num_sm = GetTakeNumStretchMarkers(f_take); // num of SMs
	num_sm !=0 ?
	(
		sp1 = 0; p1 = 0;
		sp2=0; smc = 0;
		while (smc < num_sm) // scan stretch markers to find SM indexes either side of marker.
		(
			GetTakeStretchMarker(f_take, smc, pos, spos);
			pos <= cmip ? // compare compensated (SM-moved) with SM *pos*
			(
				smi = smc; // sm index = sm count
				sp1 = spos; // source-pos1 = source pos of this sm
				p1 = pos // pos1 = pos of this sm
			):(	
				sp2 = spos; // else source-pos2 = source pos of this sm
				p2 = pos; // pos2 = pos of this sm
				smc = num_sm+1; // exit loop
			);
			smc +=1;
		);
		GetTakeStretchMarker(lm_take, smi, p1, sp1); // get LHS SM
		smi < num_sm -1 ? 
		(
			ucmip = rev_sm_comp(sp1, p1, sp2, p2, cmip);  // calc uncompensated mkr item position (*item* time)
			section_playrate = ((sp2-sp1)/(p2-p1))*take_playrate;
		):(
			ucmip = (cmip - p1) + sp1; // beyond last SM, item time becomes sp1 at p1 and SM rate =1
			section_playrate = take_playrate;
		);
		position_source_offset = ucmip + take_offset; // convert from item pos to source position
		sm_dev_flag = num_sm>=3 && (sp1 != p1 || sp2 != p2) && (sp1-p1) != (sp2-p2) && smi < num_sm-1; // set SM deviated flag (either side SM moved)
		
	):(
	// Calculate a position's source offset, using item & take parameters...
		sp1 =0; p1 =0; sp2 =0; p2 =0; sm_dev_flag =0; // reset values if no SMs
		position_source_offset = (f_position - item_pos) * take_playrate + take_offset; // no SMs
	);
	position_source_offset; // return value
);

// FROM PLANET NINE
function show_source_item_length(item, take) local(len_percent)
	(
	#src_len_buf = ""; // clear #src_len_buf - (global)
	#src_itm_len_buf = ""; // clear #src_itm_len_buf - (global)
	#src_len_perc_buf = "";

	num_sm = GetTakeNumStretchMarkers(take); // num of SMs
	num_sm ==0 ? 
	(
		sp1 =0; p1 =0; sp2 =0; p2 =0; sm_dev_flag =0; // reset values if no SMs
		//section_playrate = take_playrate;
		stp = take_start_offset + (item_length * take_playrate);
	):(
		stp = src_offset(item_pos+item_length, item, take); // comp for SMs
	);
	src_item_end_time = stp; // src_item_stt_time + (item_length * take_playrate);

	//This needs to be calc'd from source time @end - source time start.
	
	
	src_item_length = src_item_end_time - src_item_stt_time; //item_length * take_playrate;
	len_percent = (src_item_length / source_length) * 100;
	//format_timestr_pos(src_item_length, #src_itm_len_buf, ecp_format); // src_item_length value is stored to #src_itm_len_buf
	//sprintf(#src_len_perc_buf,"%0.1f",len_percent); // len_percent value is stored to #src_len_perc_buf
);

// MAIN
function check_duplicate_audio() local(i, item, j, take, k)
(

	// COUNT SELECTED ITEMS
	countSelectedMediaItem = CountSelectedMediaItems(0);
	msg_tvoldi("Number of selected items: ", countSelectedMediaItem, "%d", 1, 1, 1);

	// LOOP THROUGH SELECTION
	j=0;
	loop(countSelectedMediaItem - 1,
		(itemA = GetSelectedMediaItem(0, j)) ? ( 
			
			// CHECK THE LOOP
			msg_tvoldi("\n", NULL, 0, 0, debug, 0);
			msg_tvoldi("==========\nJ =", j, "%d", 0, debug, 1);
			
			takeA = GetActiveTake(itemA);

			TakeIsMIDI(takeA) === 1 ? (
				
					// TAKE IS MIDI
					msg_tvold("itemA ID", itemA, "%d", 0, debug);
					msg_s("takeA is MIDI");
					msg_tvold("=====", 0, "%s", 0, debug);
				
				):(
				
					// TAKE IS AUDIO
					msg_tvold("itemA ID", itemA, "%d", 0, debug);
					msg_s("takeA is Audio");

					// GET itemA PROPERTIES
					
					// Name
					GetTakeName(#retval, takeA);
					match("%s", #retval, takeAName);
					msg_tvold("takeA name", takeAName, "%s", 0, debug);
					itemASource = GetMediaItemTake_Source(takeA);
					GetMediaSourceFileName(itemASource, #filenamebuf);
					itemASourceName = #filenamebuf;
					msg_stl("itemA source path and name", itemASourceName, 1);

					// PLANETNINE SOURCE TIME POSITION TOOL INIT
					PCM_Source_GetSectionInfo(itemASource, A_offset, A_source_length, A_reverse);
					itemA_pos = GetMediaItemInfo_value(itemA, "D_POSITION");
					itemA_length = GetMediaItemInfo_value(itemA, "D_LENGTH");
					takeA_offset = GetMediaItemTakeInfo_value(takeA, "D_STARTOFFS");
					takeA_playrate = GetMediaItemTakeInfo_value(takeA, "D_PLAYRATE");
					takeA_start_offset = GetMediaItemTakeInfo_value(takeA, "D_STARTOFFS");

					itemA_end = itemA_pos + itemA_length;

					
					// itemA START SOURCE
					A_num_sm = GetTakeNumStretchMarkers(takeA); // num of SMs
					A_num_sm ==0 ? 
					(
						A_sp1 =0; A_p1 =0; A_sp2 =0; A_p2 =0; A_sm_dev_flag =0; // reset values if no SMs
						//section_playrate = take_playrate;
						A_stp = takeA_start_offset;
					):(
						A_stp = src_offset(itemA_pos, itemA, takeA); // comp for SMs
					);

					A_src_item_stt_time = A_stp; //take_start_offset;
					msg_tvold("Source in time", A_src_item_stt_time, "%f", 0, debug);

					
					
					// itemA SOURCE LENGHT
					A_num_sm = GetTakeNumStretchMarkers(takeA); // num of SMs
					A_num_sm ==0 ? 
					(
						A_sp1 =0; A_p1 =0; A_sp2 =0; A_p2 =0; A_sm_dev_flag =0; // reset values if no SMs
						//section_playrate = take_playrate;
						A_stp = takeA_start_offset + (itemA_length * takeA_playrate);
					):(
						A_stp = src_offset(itemA_pos+itemA_length, itemA, takeA); // comp for SMs
					);
					A_src_item_end_time = A_stp; // A_src_item_stt_time + (itemA_length * take_playrate);
					msg_tvold("Source lenght (seconds)", A_src_item_end_time, "%f", 0, debug);

					//This needs to be calc'd from source time @end - source time start.	

					A_src_item_length = A_src_item_end_time - A_src_item_stt_time; //itemA_length * take_playrate;
					A_len_percent = (A_src_item_length / A_source_length) * 100;
					msg_tvold("Source lenght (seconds)", A_src_item_length, "%f", 0, debug);
					

					// itemA END SOURCE AND LOOP NUMBER
					A_repeat_num = ceil(A_src_item_end_time/A_source_length)-1;
					A_A_src_item_end_time = A_src_item_end_time - (A_source_length * (ceil(A_src_item_end_time/A_source_length)-1)); // modulus = n-d*int(n/d)
					A_repeat_num ? ( // source repeated at cursor position?
							msg_tvold("Source loops", A_repeat_num, "%d", 1, debug);

							A_src_item_end_time = A_source_length; // If itemAs loop, then consider the end of first source as the end
						
						);

					// If itemA has start source before end (if loop, it loop since 0 in source)
					A_src_item_end_time < A_src_item_end_time ? (
					// COMPARE WITH THE REST - FROM HEDA
					// this new loop searches the new pooled selected itemAs and assigns them a "pool" attribute to filter them later.
					k=0; // starting from j, I think it works.
					k=j+1; // TEST
					loop(CountSelectedMediaItems(0),
					(itemB = GetSelectedMediaItem(0, k)) ? (
						 	
							//k != j && k > j ? (// CHECK THE LOOP facultative=
							msg_tvoldi("K =", j, "%d", 0, debug, 1);
							
							// Select j item from loop

							takeB = GetActiveTake(itemB); // is the item selected?
							TakeIsMIDI(takeB) === 0 ? (
								itemBSource = GetMediaItemTake_Source(takeB);
								GetMediaSourceFileName(itemBSource, #filenamebuf2);
								itemBSourceName = #filenamebuf2;
								msg_stl("itemB source path and name", itemBSourceName, 1);
								#retval = "";
								GetTakeName(#retval, takeB);
								match("%s", #retval, takeBName);
								msg_tvold("takeB name", takeBName, "%s", 0, debug);

								PCM_Source_GetSectionInfo(itemBSource, B_offset, B_source_length, B_reverse);
								itemB_pos = GetMediaItemInfo_value(itemB, "D_POSITION");
								itemB_length = GetMediaItemInfo_value(itemB, "D_LENGTH");
								takeB_offset = GetMediaItemTakeInfo_value(takeB, "D_STARTOFFS");
								takeB_playrate = GetMediaItemTakeInfo_value(takeB, "D_PLAYRATE");
								takeB_start_offset = GetMediaItemTakeInfo_value(takeB, "D_STARTOFFS");
								itemB_end = itemB_pos + itemB_length;

								
								// itemB START SOURCE
								B_num_sm = GetTakeNumStretchMarkers(takeB); // num of SMs
								B_num_sm == 0 ? 
								(
									B_sp1 =0; B_p1 =0; B_sp2 =0; B_p2 =0; B_sm_dev_flag =0; // reset values if no SMs
									//section_playrate = take_playrate;
									B_stp = takeB_start_offset;
								):(
									B_stp = src_offset(itemB_pos, itemB, takeB); // comp for SMs
								);

								B_src_item_stt_time = B_stp; //take_start_offset;
								msg_tvold("Compare source in time", B_src_item_stt_time, "%f", 0, debug);

								
								
								// itemB SOURCE LENGHT
								B_num_sm = GetTakeNumStretchMarkers(takeB); // num of SMs
								B_num_sm ==0 ? 
								(
									B_sp1 =0; B_p1 =0; B_sp2 =0; B_p2 =0; B_sm_dev_flag =0; // reset values if no SMs
									//section_playrate = take_playrate;
									B_stp = takeB_start_offset + (itemB_length * takeB_playrate);
								):(
									B_stp = src_offset(itemB_pos+itemB_length, itemB, takeB); // comp for SMs
								);
								B_src_item_end_time = B_stp; // src_item_stt_time + (item_length * take_playrate);
								msg_tvold("Compare source lenght (seconds)", B_src_item_end_time, "%f", 0, debug);

								//This needs to be calc'd from source time @end - source time start.	

								B_src_item_length = B_src_item_end_time - B_src_item_stt_time; //item_length * take_playrate;
								B_len_percent = (B_src_item_length / B_source_length) * 100;
								msg_tvold("Compare source end (seconds)", B_src_item_length, "%f", 0, debug);
								

								// itemB END SOURCE AND LOOP NUMBER
								B_repeat_num = ceil(B_src_item_end_time/B_source_length)-1;
								B_src_item_end_time = B_src_item_end_time - (B_source_length * (ceil(B_src_item_end_time/B_source_length)-1)); // modulus = n-d*int(n/d)
								B_repeat_num ? ( // source repeated at cursor position?
										msg_tvold("Compare Source loops", B_repeat_num, "%d", 0, debug);
										compate_src_item_end_time = B_source_length;
									);

								B_src_item_stt_time < B_src_item_end_time ? (
								// COMPARE
								strcmp(itemBSourceName,itemASourceName) === 0 ? (
									
									//DEBUG
									/*msg_tvold("→→→→→", NULL, NULL, 0, debug);
									msg_tvold("COMMON SOURCE", NULL, NULL, 0, debug);
									GetTakeName(#retval, takeA);
									match("%s", #retval, takeAName);
									msg_tvold("takeA name", takeAName, "%s", 0, debug);
									GetTakeName(#retval, takeB);
									match("%s", #retval, takeBName);
									msg_tvold("takeB name", takeBName, "%s", 0, debug);*/
									
									duplicateItems = 0;
									commonLengh = 0;

									// CASE 1 - A BEFORE B
									// [_A_]
									//   [_B_]
									A_src_item_stt_time <= B_src_item_stt_time && A_src_item_end_time >= B_src_item_stt_time && A_src_item_end_time <= B_src_item_end_time ? (

										commonLengh = A_src_item_end_time - B_src_item_stt_time;
										inSource = B_src_item_length;
										outSource = A_src_item_end_time;

										commonPosition1 = itemB_pos;
										commonPosition2 = itemA_end;

									);
									
									// CASE 2 - A INSIDE B
									//   [_A_]
									//  [__B__]
									A_src_item_stt_time >= B_src_item_stt_time && A_src_item_end_time <= B_src_item_end_time ? (

										commonLengh = A_src_item_length;
										inSource = A_src_item_stt_time;
										outSource = B_src_item_end_time;

										commonPosition1 = itemA_pos;
										//commonPosition2 = itemB_end;
									
									);
									
									// CASE 3 - A CONTAINS B
									//  [__A__]
									//   [_B_]
									A_src_item_stt_time <= B_src_item_stt_time && A_src_item_end_time >= B_src_item_end_time ? (
										
										commonLengh = B_src_item_length;
										inSource = B_src_item_stt_time;
										outSource = B_src_item_end_time;

										commonPosition1 = itemB_pos;
										//commonPosition2 = itemA_end;
									
									);

									// CASE 4 - A AFTER B
									//   [_A_]
									// [_B_]
									A_src_item_stt_time >= B_src_item_stt_time && A_src_item_stt_time <= B_src_item_end_time && A_src_item_end_time >= B_src_item_end_time ? (

										commonLengh = B_src_item_end_time - A_src_item_stt_time;
										inSource = A_src_item_stt_time;
										outSource = B_src_item_end_time;

										commonPosition1 = itemB_pos;
										//commonPosition2 = itemA_end;

									);
									// CASE 5 - A EQUALS B
									// [_A_]
									// [_B_]
									A_src_item_stt_time === B_src_item_stt_time && A_src_item_end_time === B_src_item_end_time ? (

										commonLengh = 1;
										duplicateItems = 1;

										commonPosition1 = itemA_end;
										//commonPosition2 = itemA_end; // If item A don"t loop from source 0.

									);

									commonLengh > 0 ? (
										msg_tvold("\nCOMMON SOURCE", NULL, NULL, 0, 1);
										msg_tvold(NULL, itemBSourceName, "%s", 1, 1)
										GetTakeName(#retval, takeA);
										match("%s", #retval, takeAName);
										msg_tvold("takeA name", takeAName, "%s", 0, 1);
										GetTakeName(#retval, takeB);
										match("%s", #retval, takeBName);
										msg_tvold("takeB name", takeBName, "%s", 0, 1);
									);

									// RESOLUTION
									commonLengh > 0 && duplicateItems == 0 ? (
										format_timestr_pos(commonPosition1, #commonPosition1, ecp_format);
										msg_tvoldi("At position:", #commonPosition1, "%s", 0, 1, 1);
										//msg_tvoldi("And position:", commonPosition2, "%f", 0, 1, 1);
										msg_tvoldi("During (source rate):", commonLengh, "%f", 0, 1, 1);	
										msg_s("\n");									
									);

									commonLengh == 0 ? (
										msg_tvold("... without overlapping.", NULL, NULL, 0, debug);
									);

									duplicateItems >= 1 ? (
										msg_tvold("... with the same properties.", NULL, NULL, 0, 1);
									);

									msg_tvold("←←←←←", NULL, NULL, 0, debug);

									):(
									
									msg_tvold("DIFFERENT SOURCES", NULL, NULL, 0, debug);
								
									);
								);
							//);
						);
						
						k+=1;
					
					);
					);
				
				);
			
			j += 1;
			msg_tvold("==========", NULL, NULL, 0, 1);
			
			);
		
		);
	
	);

);

msg_start(); // Display characters in the console to show you the begining of the script execution.

check_duplicate_audio(); // Execute your main function

msg_end(); // Display characters in the console to show you the end of the script execution.

// CAS DES ITEMS QUI ONT START APRES END (que ce soit en original ou en compare) - qui ne loop pas a partir du start

// DUREE DE SIMILITUTE SOURCE COMPENSEE

// POINT DE SIMILITUDE SOURCE 2 COMPENSEE

// USER INPUTS CONSIDERIN PLARATE AND PITCH ?




// DOESNT CONSIDER TAKE RATE CHANGE AS A DIFFERENT SOURCE
//SAME FOR PICTH !!! Oui mais pitch envelope ? PItch envelope a overlaping ?
// PAS CONDIERER LES BOUCLES NE PARTANT PAS DE  0?